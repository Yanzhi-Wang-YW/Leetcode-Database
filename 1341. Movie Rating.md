```md
1341. Movie Rating  
Table: Movies

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| title         | varchar |
+---------------+---------+
movie_id is the primary key (column with unique values) for this table.
title is the name of the movie.
Each movie has a unique title.
Table: Users

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | int     |
| name          | varchar |
+---------------+---------+
user_id is the primary key (column with unique values) for this table.
The column 'name' has unique values.
Table: MovieRating

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| movie_id      | int     |
| user_id       | int     |
| rating        | int     |
| created_at    | date    |
+---------------+---------+
(movie_id, user_id) is the primary key (column with unique values) for this table.
This table contains the rating of a movie by a user in their review.
created_at is the user's review date. 
 

Write a solution to:

Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name.
The result format is in the following example.

 

Example 1:

Input: 
Movies table:
+-------------+--------------+
| movie_id    |  title       |
+-------------+--------------+
| 1           | Avengers     |
| 2           | Frozen 2     |
| 3           | Joker        |
+-------------+--------------+
Users table:
+-------------+--------------+
| user_id     |  name        |
+-------------+--------------+
| 1           | Daniel       |
| 2           | Monica       |
| 3           | Maria        |
| 4           | James        |
+-------------+--------------+
MovieRating table:
+-------------+--------------+--------------+-------------+
| movie_id    | user_id      | rating       | created_at  |
+-------------+--------------+--------------+-------------+
| 1           | 1            | 3            | 2020-01-12  |
| 1           | 2            | 4            | 2020-02-11  |
| 1           | 3            | 2            | 2020-02-12  |
| 1           | 4            | 1            | 2020-01-01  |
| 2           | 1            | 5            | 2020-02-17  | 
| 2           | 2            | 2            | 2020-02-01  | 
| 2           | 3            | 2            | 2020-03-01  |
| 3           | 1            | 3            | 2020-02-22  | 
| 3           | 2            | 4            | 2020-02-25  | 
+-------------+--------------+--------------+-------------+
Output: 
+--------------+
| results      |
+--------------+
| Daniel       |
| Frozen 2     |
+--------------+
Explanation: 
Daniel and Monica have rated 3 movies ("Avengers", "Frozen 2" and "Joker") but Daniel is smaller lexicographically.
Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically
```

```py
import pandas as pd

def movie_rating(movies: pd.DataFrame, users: pd.DataFrame, movie_rating: pd.DataFrame) -> pd.DataFrame:
    tb1 = movie_rating.copy()
    tb1 = tb1.groupby('user_id').agg(
            movie_cnt=('movie_id', 'nunique') 
        ).reset_index() 
    customTransformations1 = tb1  
    # Join inlineInput2 and customTransformations1
    join1 = pd.merge(users, customTransformations1, left_on=["user_id"], right_on=["user_id"], how="inner")


    tb2 = join1.copy() 
    tb2 = tb2.sort_values(['movie_cnt', 'name'], ascending=[False, True]) 
    tb2 = tb2.reset_index(drop=True) 
    tb2['row_num'] = tb2.index + 1
    tb2 = tb2.rename(columns={'index': 'row_num'}) 
    tb2 = tb2[['movie_cnt', 'name', 'row_num']]   
    customTransformations2 = tb2 

    tb3 = customTransformations2.copy() 
    tb3 = tb3.loc[tb3['row_num'] == 1] 
    customTransformations3 = tb3

    tb5 = movie_rating.copy() 
    tb5['created_at'] = pd.to_datetime(tb5['created_at']) 
    tb5 = tb5.loc[tb5['created_at'].dt.strftime('%Y-%m') == '2020-02'] 
    customTransformations4 = tb5

    tb4 = customTransformations4.copy()
    tb4 = tb4.groupby('movie_id').agg(
            avg_rating=('rating', 'mean') 
        ).reset_index()  
    customTransformations5 = tb4  
    # Join customTransformations5 and inlineInput1
    join2 = pd.merge(customTransformations5, movies, left_on=["movie_id"], right_on=["movie_id"], how="inner")


    tb6 = join2.copy() 
    tb6 = tb6.sort_values(['avg_rating', 'title'], ascending=[False, True]) 
    tb6 = tb6.reset_index(drop=True) 
    tb6['row_num'] = tb6.index + 1
    tb6 = tb6.rename(columns={'index': 'row_num'}) 
    tb6 = tb6[['avg_rating', 'title', 'row_num']]    
    customTransformations6 = tb6  

    tb7 = customTransformations6.copy() 
    tb7 = tb7.loc[tb7['row_num'] == 1] 
    tb7 = tb7[['title']] 
    tb7 = tb7.rename(columns={'title': 'results'})
    customTransformations7 = tb7   


    tb8 = customTransformations3.copy() 
    tb8 = tb8.loc[tb8['row_num'] == 1] 
    tb8 = tb8[['name']] 
    tb8 = tb8.rename(columns={'name': 'results'})
    customTransformations8 = tb8     


    # Concatenate dataframes
    concat1 = pd.concat([customTransformations8, customTransformations7], ignore_index=True, sort=False, axis=0) 
    return concat1 
``` 

Here is the step-by-step table flowchart with the corresponding Python code.

### **Step 1: Load Input Data**
Three tables are loaded into memory: `Movies`, `Users`, and `MovieRating`.

**Python Code:**
```python
# Loading Movies
inlineInput1 = pd.read_csv(StringIO(inlineInput1_data)).convert_dtypes()

# Loading Users
inlineInput2 = pd.read_csv(StringIO(inlineInput2_data)).convert_dtypes()

# Loading MovieRating
inlineInput3 = pd.read_csv(StringIO(inlineInput3_data)).convert_dtypes()
```

**Table Outputs:**
**`Movies` (`inlineInput1`)**
| movie_id | title |
| :--- | :--- |
| 1 | Avengers |
| 2 | Frozen 2 |
| 3 | Joker |

**`Users` (`inlineInput2`)**
| user_id | name |
| :--- | :--- |
| 1 | Daniel |
| 2 | Monica |
| 3 | Maria |
| 4 | James |

**`MovieRating` (`inlineInput3`)**
| movie_id | user_id | rating | created_at |
| :--- | :--- | :--- | :--- |
| 1 | 1 | 3 | 2020-01-12 |
| 1 | 2 | 4 | 2020-02-11 |
| 1 | 3 | 2 | 2020-02-12 |
| 1 | 4 | 1 | 2020-01-01 |
| 2 | 1 | 5 | 2020-02-17 |
| 2 | 2 | 2 | 2020-02-01 |
| 2 | 3 | 2 | 2020-03-01 |
| 3 | 1 | 3 | 2020-02-22 |
| 3 | 2 | 4 | 2020-02-25 |

---

### **Step 2: Count Movies Reviewed per User**
The `MovieRating` table is grouped by `user_id` to count how many unique movies each user rated.

**Python Code:**
```python
tb1 = inlineInput3.groupby('user_id').agg(
    movie_cnt=('movie_id', 'nunique')
).reset_index()
```

**Table Output (`tb1`):**
| user_id | movie_cnt |
| :--- | :--- |
| 1 | 3 |
| 2 | 3 |
| 3 | 2 |
| 4 | 1 |

---

### **Step 3: Join Users with Review Counts**
The movie counts are joined with the `Users` table using an Inner Join.

**Python Code:**
```python
join1 = pd.merge(inlineInput2, tb1, on='user_id', how='inner')
```

**Table Output (`join1`):**
| user_id | name | movie_cnt |
| :--- | :--- | :--- |
| 1 | Daniel | 3 |
| 2 | Monica | 3 |
| 3 | Maria | 2 |
| 4 | James | 1 |

---

### **Step 4: Rank Users and Find Top Reviewer**
The users are sorted by `movie_cnt` (descending) and then by `name` (ascending). A `row_num` is added to identify the top user.

**Python Code:**
```python
tb2 = join1.sort_values(['movie_cnt', 'name'], ascending=[False, True])
tb2 = tb2.reset_index(drop=True)
tb2['row_num'] = tb2.index + 1
tb2 = tb2[['movie_cnt', 'name', 'row_num']]
```

**Table Output (`tb2`):**
| movie_cnt | name | row_num |
| :--- | :--- | :--- |
| 3 | Daniel | 1 |
| 3 | Monica | 2 |
| 2 | Maria | 3 |
| 1 | James | 4 |

**Filter Top User (`customTransformations3`):**
```python
customTransformations3 = tb2.loc[tb2['row_num'] == 1]
```
*(Result: `Daniel` with `movie_cnt: 3`)*

---

### **Step 5: Filter Ratings by Date (Feb 2020)**
The `MovieRating` table is filtered to keep only reviews created in February 2020 (`2020-02`).

**Python Code:**
```python
tb5 = inlineInput3.copy()
tb5['created_at'] = pd.to_datetime(tb5['created_at'])
tb5 = tb5.loc[tb5['created_at'].dt.strftime('%Y-%m') == '2020-02']
```

**Table Output (`customTransformations4`):**
| movie_id | user_id | rating | created_at |
| :--- | :--- | :--- | :--- |
| 1 | 2 | 4 | 2020-02-11 |
| 1 | 3 | 2 | 2020-02-12 |
| 2 | 1 | 5 | 2020-02-17 |
| 2 | 2 | 2 | 2020-02-01 |
| 3 | 1 | 3 | 2020-02-22 |
| 3 | 2 | 4 | 2020-02-25 |

---

### **Step 6: Calculate Average Rating per Movie**
The filtered ratings are grouped by `movie_id` to calculate the average rating.

**Python Code:**
```python
tb4 = customTransformations4.groupby('movie_id').agg(
    avg_rating=('rating', 'mean')
).reset_index()
```

**Table Output (`tb4`):**
*(Note: Movie 1: (4+2)/2 = 3.0, Movie 2: (5+2)/2 = 3.5, Movie 3: (3+4)/2 = 3.5)*
| movie_id | avg_rating |
| :--- | :--- |
| 1 | 3.0 |
| 2 | 3.5 |
| 3 | 3.5 |

---

### **Step 7: Join Ratings with Movies and Rank**
The average ratings are joined with the `Movies` table. The results are sorted by `avg_rating` (descending) and `title` (ascending).

**Python Code:**
```python
join2 = pd.merge(tb4, inlineInput1, on='movie_id', how='inner')
tb6 = join2.sort_values(['avg_rating', 'title'], ascending=[False, True])
tb6 = tb6.reset_index(drop=True)
tb6['row_num'] = tb6.index + 1
tb6 = tb6[['avg_rating', 'title', 'row_num']]
```

**Table Output (`tb6`):**
| avg_rating | title | row_num |
| :--- | :--- | :--- |
| 3.5 | Frozen 2 | 1 |
| 3.5 | Joker | 2 |
| 3.0 | Avengers | 3 |

---

### **Step 8: Identify Top Movie**
The top-ranked movie is selected (Row 1). The column is renamed to `results`.

**Python Code:**
```python
customTransformations7 = tb6.loc[tb6['row_num'] == 1]
customTransformations7 = customTransformations7[['title']].rename(columns={'title': 'results'})
```

**Table Output (`customTransformations7`):**
| results |
| :--- |
| Frozen 2 |

---

### **Step 9: Format Top User**
The top user identified in Step 4 is formatted. The column is renamed to `results`.

**Python Code:**
```python
customTransformations8 = customTransformations3.loc[customTransformations3['row_num'] == 1]
customTransformations8 = customTransformations8[['name']].rename(columns={'name': 'results'})
```

**Table Output (`customTransformations8`):**
| results |
| :--- |
| Daniel |

---

### **Step 10: Concatenate Results**
The top user and top movie tables are combined vertically into a single result list.

**Python Code:**
```python
concat1 = pd.concat([customTransformations8, customTransformations7], ignore_index=True, sort=False, axis=0)
```

**Final Table Output (`concat1`):**
| results |
| :--- |
| Daniel |
| Frozen 2 | 




















