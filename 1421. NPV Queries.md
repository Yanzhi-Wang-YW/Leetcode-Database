```md
1421. NPV Queries  
Table: NPV

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| year          | int     |
| npv           | int     |
+---------------+---------+
(id, year) is the primary key (combination of columns with unique values) of this table.
The table has information about the id and the year of each inventory and the corresponding net present value.
 

Table: Queries

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| year          | int     |
+---------------+---------+
(id, year) is the primary key (combination of columns with unique values) of this table.
The table has information about the id and the year of each inventory query.
 

Write a solution to find the npv of each query of the Queries table.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
NPV table:
+------+--------+--------+
| id   | year   | npv    |
+------+--------+--------+
| 1    | 2018   | 100    |
| 7    | 2020   | 30     |
| 13   | 2019   | 40     |
| 1    | 2019   | 113    |
| 2    | 2008   | 121    |
| 3    | 2009   | 12     |
| 11   | 2020   | 99     |
| 7    | 2019   | 0      |
+------+--------+--------+
Queries table:
+------+--------+
| id   | year   |
+------+--------+
| 1    | 2019   |
| 2    | 2008   |
| 3    | 2009   |
| 7    | 2018   |
| 7    | 2019   |
| 7    | 2020   |
| 13   | 2019   |
+------+--------+
Output: 
+------+--------+--------+
| id   | year   | npv    |
+------+--------+--------+
| 1    | 2019   | 113    |
| 2    | 2008   | 121    |
| 3    | 2009   | 12     |
| 7    | 2018   | 0      |
| 7    | 2019   | 0      |
| 7    | 2020   | 30     |
| 13   | 2019   | 40     |
+------+--------+--------+
Explanation: 
The npv value of (7, 2018) is not present in the NPV table, we consider it 0.
The npv values of all other queries can be found in the NPV table
```

```py
import pandas as pd

def npv_queries(npv: pd.DataFrame, queries: pd.DataFrame) -> pd.DataFrame: 
    output = queries.merge(npv, how='left', on=['id', 'year']) 
    output = output.fillna(value=0)   
    return output 
```

 Here is the step-by-step table flowchart with the corresponding Python code for the `npv_queries` function.

### **Step 1: Load Input Data**
Two tables are loaded into memory: `NPV` and `Queries`.

**Python Code:**
```python
# Assuming npv and queries DataFrames are already loaded as per the function input
# npv = ...
# queries = ...
```

**Table Outputs:**
**`NPV`**
| id | year | npv |
| :--- | :--- | :--- |
| 1 | 2018 | 100 |
| 7 | 2020 | 30 |
| 13 | 2019 | 40 |
| 1 | 2019 | 113 |
| 2 | 2008 | 121 |
| 3 | 2009 | 12 |
| 11 | 2020 | 99 |
| 7 | 2019 | 0 |

**`Queries`**
| id | year |
| :--- | :--- |
| 1 | 2019 |
| 2 | 2008 |
| 3 | 2009 |
| 7 | 2018 |
| 7 | 2019 |
| 7 | 2020 |
| 13 | 2019 |

---

### **Step 2: Merge Queries with NPV**
The `queries` table is joined with the `npv` table using a **Left Join**.
*   The join is performed on both `id` and `year`.
*   If a specific `id` and `year` combination exists in `NPV`, the `npv` value is retrieved.
*   If no match is found, the `npv` column will be `NaN`.

**Python Code:**
```python
output = queries.merge(npv, how='left', on=['id', 'year'])
```

**Table Output (`output`):**
| id | year | npv |
| :--- | :--- | :--- |
| 1 | 2019 | 113 |
| 2 | 2008 | 121 |
| 3 | 2009 | 12 |
| 7 | 2018 | **NaN** |
| 7 | 2019 | 0 |
| 7 | 2020 | 30 |
| 13 | 2019 | 40 |

*(Note: Row 4 `(7, 2018)` results in `NaN` because that combination does not exist in the NPV table).*

---

### **Step 3: Fill Missing Values**
Any `NaN` values in the `npv` column are replaced with `0`.

**Python Code:**
```python
output = output.fillna(value=0)
```

**Final Table Output (`output`):**
| id | year | npv |
| :--- | :--- | :--- |
| 1 | 2019 | 113 |
| 2 | 2008 | 121 |
| 3 | 2009 | 12 |
| 7 | 2018 | 0 |
| 7 | 2019 | 0 |
| 7 | 2020 | 30 |
| 13 | 2019 | 40 |  
