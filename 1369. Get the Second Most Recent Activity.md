```md
1369. Get the Second Most Recent Activity  
Table: UserActivity

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| username      | varchar |
| activity      | varchar |
| startDate     | Date    |
| endDate       | Date    |
+---------------+---------+
This table may contain duplicates rows.
This table contains information about the activity performed by each user in a period of time.
A person with username performed an activity from startDate to endDate.
 

Write a solution to show the second most recent activity of each user.

If the user only has one activity, return that one. A user cannot perform more than one activity at the same time.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
UserActivity table:
+------------+--------------+-------------+-------------+
| username   | activity     | startDate   | endDate     |
+------------+--------------+-------------+-------------+
| Alice      | Travel       | 2020-02-12  | 2020-02-20  |
| Alice      | Dancing      | 2020-02-21  | 2020-02-23  |
| Alice      | Travel       | 2020-02-24  | 2020-02-28  |
| Bob        | Travel       | 2020-02-11  | 2020-02-18  |
+------------+--------------+-------------+-------------+
Output: 
+------------+--------------+-------------+-------------+
| username   | activity     | startDate   | endDate     |
+------------+--------------+-------------+-------------+
| Alice      | Dancing      | 2020-02-21  | 2020-02-23  |
| Bob        | Travel       | 2020-02-11  | 2020-02-18  |
+------------+--------------+-------------+-------------+
Explanation: 
The most recent activity of Alice is Travel from 2020-02-24 to 2020-02-28, before that she was dancing from 2020-02-21 to 2020-02-23.
Bob only has one record, we just take that one
```

```py
import pandas as pd

def second_most_recent(user_activity: pd.DataFrame) -> pd.DataFrame:
    tb1 = user_activity.copy() 
    tb1 = tb1.sort_values(['username', 'endDate'], ascending=[True, True])
    tb1['rank_num'] = tb1.groupby('username')['endDate'].rank(method='dense', ascending=False)   
    customTransformations1 = tb1  

    tb2 = customTransformations1.copy() 
    tb2['total_username'] = tb2.groupby('username').transform('size') 
    customTransformations2 = tb2 

    tb3 = customTransformations2.copy() 
    tb3 = tb3.loc[(tb3['rank_num'] == 2) | (tb3['total_username'] == 1)] 
    customTransformations3 = tb3 

    tb4 = customTransformations3.copy() 
    customTransformations4 = tb4[['username', 'activity', 'startDate', 'endDate']] 
    return customTransformations4 
``` 

Here is the step-by-step table flowchart with the corresponding Python code for the provided data pipeline.

### **Step 1: Load Data**
The data is loaded from the CSV string into a DataFrame.

**Python Code:**
```python
inlineInput1 = pd.read_csv(StringIO(inlineInput1_data)).convert_dtypes()
```

**Table Output (`inlineInput1`):**
| username | activity | startDate | endDate |
| :--- | :--- | :--- | :--- |
| Alice | Travel | 2020-02-12 | 2020-02-20 |
| Alice | Dancing | 2020-02-21 | 2020-02-23 |
| Alice | Travel | 2020-02-24 | 2020-02-28 |
| Bob | Travel | 2020-02-11 | 2020-02-18 |

---

### **Step 2: Sort and Assign Rank**
The data is sorted by `username` and `endDate` (oldest to newest). Then, a `rank_num` is assigned within each user group based on the `endDate` in **descending** order (newest date gets rank 1).

**Python Code:**
```python
tb1 = inlineInput1.sort_values(['username', 'endDate'], ascending=[True, True])
tb1['rank_num'] = tb1.groupby('username')['endDate'].rank(method='dense', ascending=False)
```

**Table Output (`customTransformations1`):**
*(Sorted by date, Ranked by newest date)*
| username | activity | startDate | endDate | **rank_num** |
| :--- | :--- | :--- | :--- | :--- |
| Alice | Travel | 2020-02-12 | 2020-02-20 | **3** |
| Alice | Dancing | 2020-02-21 | 2020-02-23 | **2** |
| Alice | Travel | 2020-02-24 | 2020-02-28 | **1** |
| Bob | Travel | 2020-02-11 | 2020-02-18 | **1** |

---

### **Step 3: Count Total Activities**
A new column `total_username` is created, which counts the total number of activities for each user using the `transform` function.

**Python Code:**
```python
tb2['total_username'] = tb2.groupby('username').transform('size')
```

**Table Output (`customTransformations2`):**
| username | activity | startDate | endDate | rank_num | **total_username** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Alice | Travel | 2020-02-12 | 2020-02-20 | 3 | **3** |
| Alice | Dancing | 2020-02-21 | 2020-02-23 | 2 | **3** |
| Alice | Travel | 2020-02-24 | 2020-02-28 | 1 | **3** |
| Bob | Travel | 2020-02-11 | 2020-02-18 | 1 | **1** |

---

### **Step 4: Filter Activities**
The table is filtered to keep rows where either:
1.  The activity is the second newest (`rank_num == 2`).
2.  The user has only one activity total (`total_username == 1`).

**Python Code:**
```python
tb3 = tb2.loc[(tb2['rank_num'] == 2) | (tb2['total_username'] == 1)]
```

**Table Output (`customTransformations3`):**
| username | activity | startDate | endDate | rank_num | total_username |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Alice | Dancing | 2020-02-21 | 2020-02-23 | 2 | 3 |
| Bob | Travel | 2020-02-11 | 2020-02-18 | 1 | 1 |

---

### **Step 5: Select Final Columns**
Only the relevant columns are selected for the final output.

**Python Code:**
```python
customTransformations4 = tb3[['username', 'activity', 'startDate', 'endDate']]
```

**Final Table Output (`customTransformations4`):**
| username | activity | startDate | endDate |
| :--- | :--- | :--- | :--- |
| Alice | Dancing | 2020-02-21 | 2020-02-23 |
| Bob | Travel | 2020-02-11 | 2020-02-18 |  
