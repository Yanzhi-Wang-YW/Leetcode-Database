```md
1364. Number of Trusted Contacts of a Customer   
Table: Customers

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| customer_name | varchar |
| email         | varchar |
+---------------+---------+
customer_id is the column of unique values for this table.
Each row of this table contains the name and the email of a customer of an online shop.
 

Table: Contacts

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| user_id       | id      |
| contact_name  | varchar |
| contact_email | varchar |
+---------------+---------+
(user_id, contact_email) is the primary key (combination of columns with unique values) for this table.
Each row of this table contains the name and email of one contact of customer with user_id.
This table contains information about people each customer trust. The contact may or may not exist in the Customers table.
 

Table: Invoices

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| invoice_id   | int     |
| price        | int     |
| user_id      | int     |
+--------------+---------+
invoice_id is the column of unique values for this table.
Each row of this table indicates that user_id has an invoice with invoice_id and a price.
 

Write a solution to find the following for each invoice_id:

customer_name: The name of the customer the invoice is related to.
price: The price of the invoice.
contacts_cnt: The number of contacts related to the customer.
trusted_contacts_cnt: The number of contacts related to the customer and at the same time they are customers to the shop. (i.e their email exists in the Customers table.)
Return the result table ordered by invoice_id.

The result format is in the following example.

 

Example 1:

Input: 
Customers table:
+-------------+---------------+--------------------+
| customer_id | customer_name | email              |
+-------------+---------------+--------------------+
| 1           | Alice         | alice@leetcode.com |
| 2           | Bob           | bob@leetcode.com   |
| 13          | John          | john@leetcode.com  |
| 6           | Alex          | alex@leetcode.com  |
+-------------+---------------+--------------------+
Contacts table:
+-------------+--------------+--------------------+
| user_id     | contact_name | contact_email      |
+-------------+--------------+--------------------+
| 1           | Bob          | bob@leetcode.com   |
| 1           | John         | john@leetcode.com  |
| 1           | Jal          | jal@leetcode.com   |
| 2           | Omar         | omar@leetcode.com  |
| 2           | Meir         | meir@leetcode.com  |
| 6           | Alice        | alice@leetcode.com |
+-------------+--------------+--------------------+
Invoices table:
+------------+-------+---------+
| invoice_id | price | user_id |
+------------+-------+---------+
| 77         | 100   | 1       |
| 88         | 200   | 1       |
| 99         | 300   | 2       |
| 66         | 400   | 2       |
| 55         | 500   | 13      |
| 44         | 60    | 6       |
+------------+-------+---------+
Output: 
+------------+---------------+-------+--------------+----------------------+
| invoice_id | customer_name | price | contacts_cnt | trusted_contacts_cnt |
+------------+---------------+-------+--------------+----------------------+
| 44         | Alex          | 60    | 1            | 1                    |
| 55         | John          | 500   | 0            | 0                    |
| 66         | Bob           | 400   | 2            | 0                    |
| 77         | Alice         | 100   | 3            | 2                    |
| 88         | Alice         | 200   | 3            | 2                    |
| 99         | Bob           | 300   | 2            | 0                    |
+------------+---------------+-------+--------------+----------------------+
Explanation: 
Alice has three contacts, two of them are trusted contacts (Bob and John).
Bob has two contacts, none of them is a trusted contact.
Alex has one contact and it is a trusted contact (Alice).
John doesn't have any contacts
```

```py
import pandas as pd

def count_trusted_contacts(customers: pd.DataFrame, contacts: pd.DataFrame, invoices: pd.DataFrame) -> pd.DataFrame:
    # contacts_cnt
    tb1 = contacts.copy() 
    tb1 = tb1.groupby('user_id').agg(
            contacts_cnt=('contact_name', 'count')
        ).reset_index()
    customTransformations1 = tb1 

    tb2 = customers.copy() 
    tb2['dummy'] = 1
    customTransformations2 = tb2 

    tb3 = contacts.copy() 
    tb3['dummy'] = 1
    customTransformations3 = tb3 
    # Join customTransformations2 and customTransformations3
    join1 = pd.merge(customTransformations2, customTransformations3, left_on=["dummy"], right_on=["dummy"], how="inner")


    # trusted_contacts_cnt
    tb4 = join1.copy() 
    tb4['is_same_email'] = np.where(
    tb4['customer_name'] == tb4['contact_name'], 
    1, 
    0 
    )
    tb4 = tb4.groupby('user_id').agg(
    trusted_contacts_cnt=('is_same_email', 'sum')
    ).reset_index() 
    customTransformations4 = tb4
    # Join inlineInput1 and customTransformations1
    join2 = pd.merge(customers, customTransformations1, left_on=["customer_id"], right_on=["user_id"], how="left")

    # Join join2 and customTransformations4
    join3 = pd.merge(join2, customTransformations4, left_on=["customer_id"], right_on=["user_id"], how="left")

    # Join inlineInput3 and join3
    join4 = pd.merge(invoices, join3, left_on=["user_id"], right_on=["customer_id"], how="left")


    tb5 = join4.copy()
    tb5 = tb5[['invoice_id', 'customer_name', 'price', 'contacts_cnt', 'trusted_contacts_cnt']]
    tb5 = tb5.sort_values(['invoice_id'], ascending=[True]) 
    tb5 = tb5.fillna(0) 
    customTransformations5 = tb5 
    return customTransformations5    
``` 

Here is the step-by-step table flowchart with the corresponding Python code for the provided data pipeline.

### **Step 1: Load Input Data**
Three tables are loaded into memory: `Customers`, `Contacts`, and `Invoices`.

**Python Code:**
```python
# Loading Customers
inlineInput1 = pd.read_csv(StringIO(inlineInput1_data)).convert_dtypes()

# Loading Contacts
inlineInput2 = pd.read_csv(StringIO(inlineInput2_data)).convert_dtypes()

# Loading Invoices
inlineInput3 = pd.read_csv(StringIO(inlineInput3_data)).convert_dtypes()
```

**Table Outputs:**
**`Customers` (`inlineInput1`)**
| customer_id | customer_name | email |
| :--- | :--- | :--- |
| 1 | Alice | alice@leetcode.com |
| 2 | Bob | bob@leetcode.com |
| 3 | Charlie | charlie@leetcode.com |
| 4 | David | david@leetcode.com |
| 5 | Eve | eve@leetcode.com |
| 6 | Alex | alex@leetcode.com |

**`Contacts` (`inlineInput2`)**
| user_id | contact_name | contact_email |
| :--- | :--- | :--- |
| 1 | Bob | bob@leetcode.com |
| 1 | John | john@leetcode.com |
| 1 | Jal | jal@leetcode.com |
| 2 | Omar | omar@leetcode.com |
| 2 | Meir | meir@leetcode.com |
| 6 | Alice | alice@leetcode.com |

**`Invoices` (`inlineInput3`)**
| invoice_id | price | user_id |
| :--- | :--- | :--- |
| 77 | 100 | 1 |
| 88 | 200 | 1 |
| 99 | 300 | 2 |
| 66 | 400 | 2 |
| 55 | 500 | 13 |
| 44 | 60 | 6 |

---

### **Step 2: Count Total Contacts**
The `Contacts` table is grouped by `user_id` to count the total number of contacts associated with each user.

**Python Code:**
```python
tb1 = inlineInput2.groupby('user_id').agg(
    contacts_cnt=('contact_name', 'count')
).reset_index()
```

**Table Output (`customTransformations1`):**
| user_id | contacts_cnt |
| :--- | :--- |
| 1 | 3 |
| 2 | 2 |
| 6 | 1 |

---

### **Step 3: Cartesian Join (Cross Join) Customers and Contacts**
A dummy column with value `1` is added to both `Customers` and `Contacts`. They are then joined on this dummy column, creating a Cartesian product (every customer matched against every contact).

**Python Code:**
```python
tb2 = inlineInput1.copy()
tb2['dummy'] = 1

tb3 = inlineInput2.copy()
tb3['dummy'] = 1

join1 = pd.merge(tb2, tb3, on='dummy', how='inner')
```

**Table Output (`join1`):**
*(Shows first few rows of the 36 combinations)*
| customer_id | customer_name | email | dummy | user_id | contact_name | contact_email |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Alice | ... | 1 | 1 | Bob | ... |
| 1 | Alice | ... | 1 | 1 | John | ... |
| ... | ... | ... | ... | ... | ... | ... |
| 2 | Bob | ... | 1 | 1 | Bob | ... |
| 6 | Alex | ... | 1 | 6 | Alice | ... |

---

### **Step 4: Count Trusted Contacts**
The joined table is filtered to find rows where the `customer_name` matches the `contact_name`. These are flagged as `1` (Trusted) or `0`. The table is then grouped by `user_id` (from the Contacts side) to sum the trusted connections.

**Python Code:**
```python
tb4 = join1.copy()
tb4['is_same_email'] = np.where(
    tb4['customer_name'] == tb4['contact_name'], 
    1, 
    0
)
tb4 = tb4.groupby('user_id').agg(
    trusted_contacts_cnt=('is_same_email', 'sum')
).reset_index()
```

**Table Output (`customTransformations4`):**
*(Only User 1 "Alice" is a contact for Customer 1 "Alice". Only User 6 "Alice" is a contact for Customer 1 "Alice")*
| user_id | trusted_contacts_cnt |
| :--- | :--- |
| 1 | 2 |
| 6 | 1 |

---

### **Step 5: Aggregate Customer Stats**
The `Customers` table is joined with the total contacts count (`customTransformations1`) and then with the trusted contacts count (`customTransformations4`). Note that `user_id` 1 and 6 have counts, while others will be `NaN`.

**Python Code:**
```python
# Join total contacts
join2 = pd.merge(inlineInput1, customTransformations1, left_on=["customer_id"], right_on=["user_id"], how="left")

# Join trusted contacts
join3 = pd.merge(join2, customTransformations4, left_on=["customer_id"], right_on=["user_id"], how="left")
```

**Table Output (`join3`):**
| customer_id | customer_name | email | user_id | contacts_cnt | trusted_contacts_cnt |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Alice | ... | 1 | 3 | 2 |
| 2 | Bob | ... | 2 | 2 | 0 |
| 3 | Charlie | ... | NaN | 0 | 0 |
| 4 | David | ... | NaN | 0 | 0 |
| 5 | Eve | ... | NaN | 0 | 0 |
| 6 | Alex | ... | 6 | 1 | 0 |

---

### **Step 6: Join Invoices with Customer Stats**
The `Invoices` table is joined with the aggregated customer stats (`join3`). This matches the `user_id` in invoices to the `customer_id` in the customer table.
*   **Note:** Invoice 55 has `user_id` 13, which does not exist in the Customers table.

**Python Code:**
```python
join4 = pd.merge(inlineInput3, join3, left_on=["user_id"], right_on=["customer_id"], how="left")
```

**Table Output (`join4`):**
| invoice_id | price | user_id | customer_name | contacts_cnt | trusted_contacts_cnt |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 77 | 100 | 1 | Alice | 3 | 2 |
| 88 | 200 | 1 | Alice | 3 | 2 |
| 99 | 300 | 2 | Bob | 2 | 0 |
| 66 | 400 | 2 | Bob | 2 | 0 |
| 55 | 500 | 13 | NaN | NaN | NaN |
| 44 | 60 | 6 | Alex | 1 | 0 |

---

### **Step 7: Final Selection and Formatting**
Columns are selected, sorted by `invoice_id`, and all `NaN` values are filled with `0`.

**Python Code:**
```python
tb5 = join4[['invoice_id', 'customer_name', 'price', 'contacts_cnt', 'trusted_contacts_cnt']]
tb5 = tb5.sort_values(['invoice_id'], ascending=[True])
tb5 = tb5.fillna(0)
```

**Final Table Output (`customTransformations5`):**
| invoice_id | customer_name | price | contacts_cnt | trusted_contacts_cnt |
| :--- | :--- | :--- | :--- | :--- |
| 44 | Alex | 60 | 1 | 0 |
| 55 | 0 | 500 | 0 | 0 |
| 66 | Bob | 400 | 2 | 0 |
| 77 | Alice | 100 | 3 | 2 |
| 88 | Alice | 200 | 3 | 2 |
| 99 | Bob | 300 | 2 | 0 | 








